# SPDX-License-Identifier: MIT
# Copyright (c) 2025 Felix Tacke

"""
analysis_tenses_make_tidy.py 

Combine the *_results_*.csv files generated by analysis_tenses.py into a single

idempotent tidy/long‐format table (tenses_tidy.csv), but only using the precomputed SUM rows.

Usage (from the repo root):
    python analysis_tenses_make_tidy.py          # writes tenses_tidy.csv next to the script
    python analysis_tenses_make_tidy.py path/to/results_dir

The resulting CSV has columns:
    country    – ISO or project code
    file       – "SUM <country>"
    mode       – libre | lectura | pre | total
    tense      – future | pasado
    variant    – analytical | synthetic
    tokens     – count of this variant summed across all recordings
    total      – sum of tokens_analytical + tokens_synthetic for that group
    prop       – tokens / total proportion per group

Only depends on pandas (>=1.5).
"""
from __future__ import annotations

import sys
from pathlib import Path
import pandas as pd

# ---------------------------------------------------------------------------
DEFAULT_PATTERN = "analysis_*_results_*.csv"
OUTFILE = "tenses_tidy.csv"


def build_tidy(base_dir: Path | str = Path(__file__).parent / "results_tenses") -> Path:
    """Scan *base_dir* for *_results_*.csv files and write a single tidy CSV, only using SUM rows."""
    base_dir = Path(base_dir).expanduser().resolve()

    files = sorted(base_dir.glob(DEFAULT_PATTERN))
    if not files:
        raise FileNotFoundError(
            f"No result CSVs matching '{DEFAULT_PATTERN}' found in {base_dir}"
        )

    records: list[pd.DataFrame] = []

    for path in files:
        df = pd.read_csv(path, sep=";")
        # Keep only the summary rows whose filename starts with "SUM "
        if "filename" in df.columns:
            df = df[df["filename"].str.startswith("SUM ")]
        else:
            continue

        name = path.stem  # e.g. analysis_future_results_lectura
        tense = "future" if "future" in name else "pasado"
        if "_libre" in name:
            mode = "libre"
        elif "_lectura" in name:
            mode = "lectura"
        elif "_pre" in name:
            mode = "pre"
        elif "_total" in name:
            mode = "total"
        else:
            raise ValueError(f"Cannot parse mode from filename: {path.name}")

        # Harmonise column names and pivot the SUM rows to long format
        if tense == "future":
            renamed = df.rename(
                columns={
                    "analyticalFuture": "analytical",
                    "simpleFuture": "synthetic",
                    "filename": "file",
                }
            )
        else:
            renamed = df.rename(
                columns={
                    "compoundPast": "analytical",
                    "simplePast": "synthetic",
                    "filename": "file",
                }
            )

        long = (
            renamed.melt(
                id_vars=["country", "file"],
                value_vars=["analytical", "synthetic"],
                var_name="variant",
                value_name="tokens",
            )
        )
        long["tense"] = tense
        long["mode"] = mode

        # Compute total tokens per SUM group (should equal sum of tokens per row)
        totals = (
            long.groupby(["country", "file", "mode", "tense"], as_index=False)["tokens"]
            .sum()
            .rename(columns={"tokens": "total"})
        )
        long = long.merge(totals, on=["country", "file", "mode", "tense"])

        # Compute proportion
        long["prop"] = long["tokens"] / long["total"]

        records.append(long)

    tidy = pd.concat(records, ignore_index=True)
    tidy = tidy[
        ["country", "file", "mode", "tense", "variant", "tokens", "total", "prop"]
    ].sort_values(["country", "file", "mode", "tense", "variant"])

    out_path = base_dir / OUTFILE
    tidy.to_csv(out_path, index=False)
    print(f"✅  Wrote tidy table with {len(tidy):,} rows to {out_path}")
    return out_path


if __name__ == "__main__":
    if len(sys.argv) > 2:
        print("Usage: python analysis_tenses_make_tidy.py [BASE_DIR]")
        sys.exit(1)
    base = Path(sys.argv[1]) if len(sys.argv) == 2 else Path(__file__).parent / "results_tenses"
    build_tidy(base)
